import type { MathSymbol } from '@/types'

export const mlSymbols: MathSymbol[] = [
  {
    symbol: 'θ',
    name: 'Theta (parameters)',
    latex: '\\theta',
    meaning: 'Model parameters',
    programmingAnalogy: 'weights array',
    pythonExample: 'theta = np.random.randn(n_features)',
    category: 'ml',
  },
  {
    symbol: 'ŷ',
    name: 'Y-hat (prediction)',
    latex: '\\hat{y}',
    meaning: 'Predicted value',
    programmingAnalogy: 'model.predict(X)',
    pythonExample: 'y_hat = model.predict(X_test)',
    category: 'ml',
  },
  {
    symbol: 'J(θ)',
    name: 'Cost function',
    latex: 'J(\\theta)',
    meaning: 'Loss/cost function',
    programmingAnalogy: 'loss_function(y, y_hat)',
    pythonExample: 'J = np.mean((y - y_hat)**2)  # MSE',
    category: 'ml',
  },
  {
    symbol: '∇J(θ)',
    name: 'Gradient',
    latex: '\\nabla J(\\theta)',
    meaning: 'Gradient of cost function',
    programmingAnalogy: 'compute_gradient()',
    pythonExample: 'gradient = (2/m) * X.T @ (X @ theta - y)',
    category: 'ml',
  },
  {
    symbol: 'α',
    name: 'Learning rate',
    latex: '\\alpha',
    meaning: 'Step size for gradient descent',
    programmingAnalogy: 'learning_rate = 0.01',
    pythonExample: 'theta = theta - alpha * gradient',
    category: 'ml',
  },
  {
    symbol: 'σ(x)',
    name: 'Sigmoid',
    latex: '\\sigma(x)',
    meaning: 'Sigmoid activation function',
    programmingAnalogy: '1 / (1 + np.exp(-x))',
    pythonExample: 'def sigmoid(x): return 1 / (1 + np.exp(-x))',
    category: 'ml',
  },
  {
    symbol: 'softmax',
    name: 'Softmax',
    latex: '\\text{softmax}(x_i)',
    meaning: 'Normalize to probability distribution',
    programmingAnalogy: 'scipy.special.softmax()',
    pythonExample: 'probs = np.exp(x) / np.sum(np.exp(x))',
    category: 'ml',
  },
  {
    symbol: 'L',
    name: 'Loss',
    latex: 'L',
    meaning: 'Loss function value',
    programmingAnalogy: 'loss = criterion(output, target)',
    pythonExample: 'loss = nn.CrossEntropyLoss()(logits, labels)',
    category: 'ml',
  },
  {
    symbol: 'E[X]',
    name: 'Expected value',
    latex: 'E[X]',
    meaning: 'Expected value / mean',
    programmingAnalogy: 'np.mean(X)',
    pythonExample: 'expected = np.mean(samples)',
    category: 'ml',
  },
  {
    symbol: 'Var(X)',
    name: 'Variance',
    latex: '\\text{Var}(X)',
    meaning: 'Variance of random variable',
    programmingAnalogy: 'np.var(X)',
    pythonExample: 'variance = np.var(samples)',
    category: 'ml',
  },
  {
    symbol: 'P(A|B)',
    name: 'Conditional probability',
    latex: 'P(A|B)',
    meaning: 'Probability of A given B',
    programmingAnalogy: '# Bayes: P(A|B) = P(B|A)P(A)/P(B)',
    pythonExample: 'p_a_given_b = (p_b_given_a * p_a) / p_b',
    category: 'ml',
  },
]
